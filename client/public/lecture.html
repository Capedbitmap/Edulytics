<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecture Transcription | Lecture Assistant</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- Using Font Awesome via CDN for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Link to shared styles -->
    <link rel="stylesheet" href="/styles/main.css">
    <style>
        /* Lecture Page Specific Styles using Theme Variables */
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        main {
            flex-grow: 1;
            padding-top: calc(var(--header-height) + 20px); /* Adjust for fixed header */
            padding-bottom: 40px;
        }

        /* Header Adjustments */
        .lecture-info-header {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .lecture-code-header {
            font-family: monospace;
            font-weight: 600;
            padding: 4px 10px;
            background-color: var(--primary-light);
            border-radius: 4px;
            color: var(--primary-dark);
            font-size: 0.9em;
        }
        .live-indicator {
            background-color: var(--accent-color); /* Use accent color for live */
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 5px;
            animation: pulseLive 1.5s infinite;
        }
        .live-indicator .dot {
            width: 8px;
            height: 8px;
            background-color: white;
            border-radius: 50%;
        }

        /* Lecture Header Card */
        .lecture-header-card {
            background-color: var(--card-background);
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-light);
            border: 1px solid var(--border-color);
            padding: 25px;
            margin-bottom: 25px;
        }
        .lecture-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--primary-dark);
            margin-bottom: 15px;
        }
        .lecture-metadata {
            display: flex;
            flex-wrap: wrap;
            gap: 15px 25px; /* Row and column gap */
            margin-bottom: 20px;
            color: var(--secondary-text);
            font-size: 0.95rem;
        }
        .metadata-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .metadata-item i { /* Font Awesome icons */
            color: var(--primary-color);
            font-size: 1.1em;
            width: 20px; /* Ensure alignment */
            text-align: center;
        }

        /* Summary Buttons */
        .summary-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .summary-buttons .btn { /* Use standard button styles */
            padding: 10px 20px;
            font-size: 0.9rem;
        }
        .summary-buttons .btn i {
            margin-right: 6px;
        }

        /* Transcription Area */
        .transcription-container {
            background-color: var(--card-background);
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-light);
            border: 1px solid var(--border-color);
            height: calc(100vh - 300px); /* Adjust height based on header/footer */
            min-height: 450px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .transcription-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-light) var(--card-background);
        }
        .transcription-content::-webkit-scrollbar { width: 8px; }
        .transcription-content::-webkit-scrollbar-track { background: var(--card-background); }
        .transcription-content::-webkit-scrollbar-thumb { background-color: var(--primary-light); border-radius: 4px; border: 2px solid var(--card-background); }

        /* Message Bubbles */
        .message-wrapper {
            display: flex;
            align-items: flex-start;
            margin-bottom: 18px;
            animation: fadeIn 0.5s ease-out;
        }
        .profile-picture {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
            flex-shrink: 0;
            background-color: var(--secondary-color); /* Use secondary color */
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 1rem;
        }
        .profile-picture img { width: 100%; height: 100%; object-fit: cover; }
        .profile-initial { display: none; } /* Hide initial by default */

        .message-bubble {
            background-color: var(--primary-light);
            padding: 12px 18px;
            border-radius: 18px;
            max-width: 85%;
            position: relative;
            box-shadow: 0 2px 5px var(--shadow-light);
            cursor: pointer;
            transition: background-color var(--transition-speed), transform 0.2s ease-out;
            color: var(--text-color);
        }
        .message-bubble:hover {
            background-color: var(--primary-color);
            color: white;
            transform: scale(1.02);
        }
        .message-bubble.clicked {
            background-color: var(--primary-dark); /* Darker when clicked */
            color: white;
            transform: scale(1.01); /* Slightly different scale */
        }
        .transcription-text {
            font-size: 1rem;
            line-height: 1.6;
            word-wrap: break-word;
        }
        .no-transcriptions {
            text-align: center;
            padding: 40px 20px;
            color: var(--secondary-text);
            font-style: italic;
        }

        /* Modal Styling */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Darker overlay */
            z-index: 1000;
            opacity: 0;
            transition: opacity var(--transition-speed);
            overflow-y: auto; /* Allow scrolling if content overflows */
            padding: 20px;
        }
        .modal.visible { opacity: 1; }
        .modal-content {
            position: relative;
            background-color: var(--card-background);
            margin: 5% auto; /* Adjust margin */
            padding: 30px;
            width: 95%;
            max-width: 750px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transform: translateY(-20px) scale(0.98);
            transition: transform var(--transition-speed) ease-out, opacity var(--transition-speed) ease-out;
            opacity: 0;
        }
        .modal.visible .modal-content { transform: translateY(0) scale(1); opacity: 1; }
        .close-button {
            position: absolute;
            right: 15px;
            top: 15px;
            font-size: 1.8rem;
            font-weight: 300;
            cursor: pointer;
            color: var(--secondary-text);
            border: none;
            background: transparent;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color var(--transition-speed), color var(--transition-speed);
        }
        .close-button:hover { background-color: var(--border-color); color: var(--text-color); }
        .modal-header { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        #modalTitle { font-size: 1.5rem; font-weight: 600; color: var(--primary-dark); }
        .option-buttons { display: flex; gap: 10px; margin-bottom: 25px; justify-content: center; flex-wrap: wrap; }
        .option-buttons .btn { font-size: 0.9rem; padding: 8px 15px; } /* Smaller buttons */
        .option-buttons .btn.active { background-color: var(--primary-dark); color: white; } /* Style for active option */

        .loading-spinner-modal { /* Renamed to avoid conflict */
            display: none;
            text-align: center;
            padding: 30px 0;
            color: var(--secondary-text);
        }
        .spinner-modal { /* Renamed */
            display: inline-block;
            width: 35px;
            height: 35px;
            border: 4px solid var(--primary-light);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
            vertical-align: middle;
        }
        .explanation-text {
            font-size: 1rem;
            line-height: 1.7;
            padding: 15px 0;
            color: var(--text-color);
            max-height: 400px; /* Explicit max height for scrolling */
            overflow-y: auto; /* Add scroll if needed */
        }
        /* Style markdown elements */
        .explanation-text h1, .explanation-text h2, .explanation-text h3 { margin-top: 1.2em; margin-bottom: 0.6em; color: var(--primary-dark); }
        .explanation-text p { margin-bottom: 1em; }
        .explanation-text ul, .explanation-text ol { margin-left: 25px; margin-bottom: 1em; }
        .explanation-text li { margin-bottom: 0.5em; }
        .explanation-text code { background-color: var(--primary-light); padding: 2px 5px; border-radius: 4px; font-family: monospace; font-size: 0.9em; }
        .explanation-text pre { background-color: var(--primary-light); padding: 15px; border-radius: 8px; overflow-x: auto; margin-bottom: 1em; }
        .explanation-text pre code { background-color: transparent; padding: 0; }
        .explanation-text blockquote { border-left: 4px solid var(--border-color); padding-left: 15px; margin: 1em 0; color: var(--secondary-text); }

        .error-message-modal { /* Renamed */
            color: #721c24;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            display: none;
            text-align: center;
        }
        .retry-button {
            display: inline-block;
            margin-left: 10px;
            text-decoration: underline;
            color: var(--primary-color);
            cursor: pointer;
            font-weight: 600;
        }

        /* Status Indicator */
        .status-indicator {
            position: fixed;
            bottom: 20px; /* Position at bottom */
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 15px;
            border-radius: 20px; /* Pill shape */
            background-color: var(--primary-dark);
            color: white;
            font-size: 0.9em;
            font-weight: 500;
            opacity: 0;
            transition: opacity var(--transition-speed), transform 0.3s ease-out;
            z-index: 2000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transform: translateX(-50%) translateY(10px);
        }
        .status-indicator.visible { opacity: 1; transform: translateX(-50%) translateY(0); }
        .status-indicator.error { background-color: #c81e1e; } /* Use a theme error color if available */

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes pulseLive { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }

        /* Responsive */
        @media (max-width: 768px) {
            .lecture-metadata { gap: 10px 15px; }
            .live-indicator { display: none; } /* Hide live indicator */
            .lecture-code-header { display: none; } /* Hide code in header */
            .lecture-title { font-size: 1.5rem; }
            .summary-buttons { flex-direction: column; }
            .summary-buttons .btn { width: 100%; }
            .message-bubble { max-width: 90%; }
            .transcription-container { height: calc(100vh - 290px); min-height: 350px; }
            .modal-content { margin: 10% auto; padding: 20px; }
            #modalTitle { font-size: 1.3rem; }
        }
         @media (max-width: 576px) {
             main { padding: 15px; padding-top: calc(var(--header-height) + 15px); }
             .lecture-header-card { padding: 20px; }
             .lecture-metadata { font-size: 0.9rem; }
             .transcription-content { padding: 15px; }
             .message-wrapper { margin-bottom: 15px; }
             .profile-picture { width: 35px; height: 35px; margin-right: 10px; font-size: 0.9rem;}
             .message-bubble { padding: 10px 15px; border-radius: 15px; }
             .transcription-text { font-size: 0.95rem; }
         }
    </style>
</head>
<body>
    <header class="main-header">
        <div class="container header-container">
            <a href="/" class="logo">
                <i class="fas fa-microphone-alt"></i>
                <span>Lecture Assistant</span>
            </a>
            <div class="header-actions">
                 <div class="lecture-info-header">
                    <span class="lecture-code-header" id="headerLectureCode"></span>
                    <div class="live-indicator" id="liveIndicator" style="display: none;">
                        <span class="dot"></span>
                        <span>LIVE</span>
                    </div>
                </div>
                <button id="theme-toggle" class="theme-toggle-btn" aria-label="Toggle dark mode">
                    <i class="fas fa-moon"></i>
                    <i class="fas fa-sun"></i>
                </button>
            </div>
        </div>
    </header>

    <main class="page-transition">
        <div class="container">
            <div class="lecture-header-card">
                <h1 class="lecture-title" id="lectureTitle">Loading lecture...</h1>
                <div class="lecture-metadata">
                    <div class="metadata-item">
                        <i class="fas fa-calendar-alt"></i>
                        <span id="lectureDate">Loading date...</span>
                    </div>
                    <div class="metadata-item">
                        <i class="fas fa-clock"></i>
                        <span id="lectureTime">Loading time...</span>
                    </div>
                    <div class="metadata-item">
                        <i class="fas fa-chalkboard-teacher"></i>
                        <span id="lectureInstructor">Loading instructor...</span>
                    </div>
                    <div class="metadata-item">
                        <i class="fas fa-key"></i>
                        <span id="lectureCode">Loading code...</span>
                    </div>
                </div>
                <div class="summary-buttons">
                    <button class="btn btn-secondary summary-button" data-minutes="1">
                        <i class="fas fa-bolt"></i> Summarize Last Minute
                    </button>
                    <button class="btn btn-secondary summary-button" data-minutes="5">
                        <i class="fas fa-stream"></i> Summarize Last 5 Min
                    </button>
                    <button class="btn btn-secondary summary-button" data-minutes="30">
                        <i class="fas fa-hourglass-half"></i> Summarize Last 30 Min
                    </button>
                    <button class="btn btn-secondary summary-button-entire">
                        <i class="fas fa-book-open"></i> Summarize Entire Lecture
                    </button>
                    <button class="btn btn-secondary practice-problems-button-lecture">
                        <i class="fas fa-question-circle"></i> Generate Practice Problems (Lecture)
                    </button>
                     <button class="btn btn-primary lecture-notes-button"> <!-- Primary style for emphasis -->
                        <i class="fas fa-file-pdf"></i> Create Lecture Notes
                    </button>
                </div>
            </div>

            <div class="transcription-container">
                <div class="transcription-content" id="transcriptionContent">
                    <p class="no-transcriptions" id="noTranscriptions">Loading lecture transcriptions...</p>
                </div>
            </div>
        </div> <!-- Close .container -->
    </main>

    <div id="explanationModal" class="modal" aria-modal="true" role="dialog" aria-labelledby="modalTitle">
        <div class="modal-content">
            <button class="close-button" onclick="closeModal()" aria-label="Close dialog">&times;</button>
            <div class="modal-header">
                <h2 id="modalTitle">Select an option</h2>
            </div>
            <div class="option-buttons">
                 <button class="btn btn-secondary option-button" data-option="define"><i class="fas fa-book"></i> Define Terms</button>
                 <button class="btn btn-secondary option-button" data-option="explain"><i class="fas fa-lightbulb"></i> Explain Detail</button>
                 <button class="btn btn-secondary option-button" data-option="examples"><i class="fas fa-vial"></i> Examples</button>
                 <button class="btn btn-secondary option-button" data-option="simplify"><i class="fas fa-child"></i> Simplify</button>
                 <button class="btn btn-secondary option-button" data-option="practice"><i class="fas fa-pencil-alt"></i> Practice Problems</button> <!-- New option -->
            </div>
            <div id="loadingSpinnerModal" class="loading-spinner-modal"> <!-- Renamed ID -->
                <div class="spinner-modal"></div> <!-- Renamed class -->
                <span>Processing your request...</span>
            </div>
            <div id="explanationText" class="explanation-text"></div>
            <div id="errorMessageModal" class="error-message-modal"> <!-- Renamed ID -->
                <p>Sorry, we encountered an error. <span id="retryButton" class="retry-button">Try again</span></p>
            </div>
        </div>
    </div>

    <div id="statusIndicator" class="status-indicator"></div>

    <footer class="main-footer"> <!-- Use standard footer -->
        <div class="container">
            <p>&copy; 2025 Lecture Assistant | All Rights Reserved</p>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        // --- Theme Toggle ---
        document.addEventListener('DOMContentLoaded', () => { // Add theme toggle logic here
            const themeToggle = document.getElementById('theme-toggle');
            const currentTheme = localStorage.getItem('theme');
            if (currentTheme === 'dark') {
                document.body.classList.add('dark-theme');
            }
            themeToggle?.addEventListener('click', () => {
                document.body.classList.toggle('dark-theme');
                let theme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
                localStorage.setItem('theme', theme);
            });
        });

        // --- Lecture Page Logic (Original Script Content) ---
        // Configuration
        const MAX_TRANSCRIPTION_HISTORY = 100;
        const CONNECTION_TIMEOUT = 10000; // 10 seconds
        const THROTTLE_DELAY = 300; // ms between transcription updates
        const POLLING_INTERVAL = 5000; // 5 seconds between polls when WebSocket fails

        // Elements
        const transcriptionContent = document.getElementById('transcriptionContent');
        const noTranscriptions = document.getElementById('noTranscriptions');
        const modal = document.getElementById('explanationModal');
        const loadingSpinnerModal = document.getElementById('loadingSpinnerModal'); // Updated ID
        const explanationText = document.getElementById('explanationText');
        const errorMessageModal = document.getElementById('errorMessageModal'); // Updated ID
        const retryButton = document.getElementById('retryButton');
        const statusIndicator = document.getElementById('statusIndicator');
        const optionButtons = document.querySelectorAll('.option-button'); // Includes the new practice button
        const liveIndicator = document.getElementById('liveIndicator');
        const summaryEntireButton = document.querySelector('.summary-button-entire');
        const practiceProblemsLectureButton = document.querySelector('.practice-problems-button-lecture');
        const lectureNotesButton = document.querySelector('.lecture-notes-button');

        // State
        let lastTranscription = '';
        let lastClickedElement = null;
        let selectedText = '';
        let selectedOption = null;
        let transcriptionHistory = [];
        let lastTranscriptionTime = 0; // Initialize to 0
        let isConnected = false;
        let connectionTimer = null;
        let lectureCode = null;
        let lectureData = null;
        let isLive = false;
        let ws = null;
        let lastTranscriptionId = null;
        let pollingActive = false;
        let pollingInterval = null;
        let highlightTerm = null; // NEW: Store the term to highlight
        let firstHighlightElement = null; // NEW: Store the first element that was highlighted

        // Instructor profile picture (can be dynamic later)
        const instructorProfilePicture = '/images/default-instructor.webp'; // Use correct absolute path
        const instructorInitial = 'I'; // Default initial

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            // Get lecture code from URL path
            const pathParts = window.location.pathname.split('/');
            if (pathParts.length >= 3 && pathParts[1] === 'lecture') {
                lectureCode = pathParts[2].toUpperCase();
                // NEW: Get highlight term from query params
                const urlParams = new URLSearchParams(window.location.search);
                highlightTerm = urlParams.get('highlight');
                if (highlightTerm) {
                    console.log("Highlight term found:", highlightTerm);
                }
                initializeLecture(lectureCode);
            } else {
                showErrorPage('Invalid lecture URL. Please return to the home page and enter a valid lecture code.');
            }
        });

        // Initialize lecture data and connection
        function initializeLecture(code) {
            // Update code display
            document.getElementById('headerLectureCode').textContent = code;
            document.getElementById('lectureCode').textContent = code;

            // Get lecture metadata
            fetch('/join_lecture', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ lecture_code: code }),
                credentials: 'same-origin'
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => { throw new Error(err.error || 'Invalid lecture code or lecture not found'); });
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    lectureData = data;
                    updateLectureInfo(data.metadata);
                    loadLectureTranscriptions(code); // Load history first
                    // connectToWebSocket(code); // WebSocket removed, rely on polling or WebRTC
                    // Start polling immediately after loading history if WS is removed
                    startPolling();
                } else {
                    throw new Error(data.error || 'Failed to join lecture');
                }
            })
            .catch(error => {
                console.error('Initialization Error:', error);
                showErrorPage('Error: ' + error.message);
            });
        }

        // Update lecture information display
        function updateLectureInfo(metadata) {
            document.getElementById('lectureTitle').textContent = metadata.course_code || 'Untitled Lecture';
            document.getElementById('lectureDate').textContent = formatDate(metadata.date) || 'N/A';
            document.getElementById('lectureTime').textContent = formatTime(metadata.time) || 'N/A';
            document.getElementById('lectureInstructor').textContent = metadata.instructor || 'N/A';
            // Update instructor initial/picture if needed
        }

        // Load existing transcriptions
        function loadLectureTranscriptions(code) {
            transcriptionContent.innerHTML = ''; // Clear first
            noTranscriptions.textContent = 'Loading lecture transcriptions...';
            transcriptionContent.appendChild(noTranscriptions); // Add placeholder back

            fetch(`/get_lecture_transcriptions?lecture_code=${code}`, { credentials: 'same-origin' })
                .then(response => {
                    if (!response.ok) throw new Error('Failed to load transcriptions');
                    return response.json();
                })
                .then(data => {
                    if (data.transcriptions && data.transcriptions.length > 0) {
                        if (noTranscriptions.parentNode) noTranscriptions.parentNode.removeChild(noTranscriptions);

                        data.transcriptions.forEach(transcription => {
                            const time = new Date(transcription.timestamp);
                            if (!transcriptionHistory.some(t => t.id === transcription.id)) {
                                transcriptionHistory.push({ text: transcription.text, timestamp: time, id: transcription.id });
                                if (transcription.timestamp > lastTranscriptionTime) {
                                    lastTranscriptionTime = transcription.timestamp;
                                    lastTranscriptionId = transcription.id;
                                }
                                // Pass highlightTerm to displayTranscription
                                displayTranscription(transcription.text, transcription.is_fallback, transcription.id);
                            }
                        });
                        // Scroll to bottom initially OR scroll to highlight
                        if (firstHighlightElement) {
                            console.log("Scrolling to first highlight element:", firstHighlightElement);
                            firstHighlightElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        } else {
                            transcriptionContent.scrollTop = transcriptionContent.scrollHeight;
                        }
                    } else {
                        noTranscriptions.textContent = 'No transcriptions available for this lecture yet.';
                    }
                    // After loading history, check status and potentially highlight
                     checkLectureStatus();
                })
                .catch(error => {
                    console.error('Load Transcriptions Error:', error);
                    noTranscriptions.textContent = 'Error loading transcriptions: ' + error.message;
                });
        }

        // WebSocket connection logic removed (connectToWebSocket function)
        // WebRTC or polling are the primary methods now.

        function handleStatusUpdate(data) {
             if (data.status === 'connected') showStatus('WebSocket ready', 'success');
             else if (data.status === 'lecture_ended') {
                 updateLiveStatus(false);
                 showStatus('Lecture has ended.', 'info');
                 if (ws) ws.close(1000, "Lecture Ended"); // Normal closure
                 stopPolling();
             }
             // Handle other status messages if needed
        }


        // Start polling
        function startPolling() {
            if (pollingActive || !lectureCode) return;
            pollingActive = true;
            console.log('Starting polling...');
            if (pollingInterval) clearInterval(pollingInterval);
            pollForNewTranscriptions(); // Poll immediately
            pollingInterval = setInterval(pollForNewTranscriptions, POLLING_INTERVAL);
        }

        // Stop polling
        function stopPolling() {
            if (!pollingActive) return;
            pollingActive = false;
            console.log('Stopping polling');
            if (pollingInterval) clearInterval(pollingInterval);
            pollingInterval = null;
        }

        // Poll for new transcriptions
        function pollForNewTranscriptions() {
            if (!lectureCode) return;
            console.log('Polling...');
            const url = `/get_lecture_transcriptions?lecture_code=${lectureCode}&since=${lastTranscriptionTime}`;

            fetch(url, { credentials: 'same-origin' })
                .then(response => {
                    if (!response.ok) throw new Error('Polling failed');
                    return response.json();
                })
                .then(data => {
                    if (data.transcriptions && data.transcriptions.length > 0) {
                        console.log(`Received ${data.transcriptions.length} new transcriptions via polling`);
                        updateLiveStatus(true); // Assume live if new data arrives
                        data.transcriptions.forEach(transcription => {
                            if (!transcriptionHistory.some(t => t.id === transcription.id)) {
                                const time = new Date(transcription.timestamp);
                                transcriptionHistory.push({ text: transcription.text, timestamp: time, id: transcription.id });
                                if (transcription.timestamp > lastTranscriptionTime) {
                                    lastTranscriptionTime = transcription.timestamp;
                                    lastTranscriptionId = transcription.id;
                                }
                                if (noTranscriptions.parentNode) noTranscriptions.parentNode.removeChild(noTranscriptions);
                                // Pass highlightTerm to displayTranscription
                                displayTranscription(transcription.text, transcription.is_fallback, transcription.id);
                            }
                        });
                        transcriptionContent.scrollTop = transcriptionContent.scrollHeight;
                    }
                    // Check status after polling
                    checkLectureStatus();
                })
                .catch(error => {
                    console.error('Polling error:', error);
                    // Continue polling even on error
                });
        }

        // Handle new transcription data
        function handleNewTranscription(data) {
            const text = data.text?.trim();
            if (!text) return; // Ignore empty transcriptions

            // Avoid displaying exact duplicates received close together
            const now = Date.now();
            if (text === lastTranscription && (now - (transcriptionHistory[transcriptionHistory.length - 1]?.timestamp?.getTime() || 0)) < 1000) {
                 console.log("Skipping duplicate transcription:", text);
                 return;
            }

            updateLiveStatus(true);
            const timestamp = new Date(data.timestamp || now);
            const id = data.item_id || `local-${now}`;

            // Add to history if not already present
            if (!transcriptionHistory.some(t => t.id === id)) {
                transcriptionHistory.push({ text: text, timestamp: timestamp, id: id });
                lastTranscription = text;
                lastTranscriptionTime = timestamp.getTime();
                lastTranscriptionId = id;

                if (transcriptionHistory.length > MAX_TRANSCRIPTION_HISTORY) transcriptionHistory.shift();
                if (noTranscriptions.parentNode) noTranscriptions.parentNode.removeChild(noTranscriptions);

                // Pass highlightTerm to displayTranscription
                displayTranscription(text, data.is_fallback, id);
                transcriptionContent.scrollTop = transcriptionContent.scrollHeight;
            }
        }

        // Check lecture status
        function checkLectureStatus() {
            if (!lectureCode) return;
            // Use the correct endpoint: /recording_status
            fetch(`/recording_status?lecture_code=${lectureCode}`, { credentials: 'same-origin' })
                .then(response => {
                    // Handle potential non-JSON responses gracefully (e.g., 404)
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Use the correct property from the response: data.is_recording
                    updateLiveStatus(data.is_recording);
                    if (!data.is_recording) {
                         // WebSocket (ws) variable no longer exists, remove check
                         // if (ws) ws.close(1000, "Lecture Ended");
                         stopPolling(); // Stop polling if lecture ended
                         showStatus('Lecture has ended.', 'info');
                    }
                })
                .catch(error => {
                    console.error('Error checking lecture status:', error);
                    updateLiveStatus(false); // Assume not live on error
                });
        }

        // Update live indicator
        function updateLiveStatus(isLiveNow) {
            if (isLive !== isLiveNow) { // Only update if status changed
                 isLive = isLiveNow;
                 liveIndicator.style.display = isLive ? 'flex' : 'none';
                 console.log("Live status updated:", isLive);
            }
        }

        // Start connection timer
        function startConnectionTimer() {
            clearTimeout(connectionTimer);
            connectionTimer = setTimeout(() => {
                if (!isConnected) {
                    showStatus('Connection timed out. Using polling...', 'error');
                    if (!pollingActive) startPolling();
                }
            }, CONNECTION_TIMEOUT);
        }

        // Display a transcription bubble, optionally highlighting text
        function displayTranscription(text, isFallback = false, transcriptionId) {
            const messageWrapper = document.createElement('div');
            messageWrapper.className = 'message-wrapper';

            const profilePic = document.createElement('div');
            profilePic.className = 'profile-picture';
            const img = document.createElement('img');
            img.src = instructorProfilePicture; // Now uses absolute path
            img.alt = 'I';
            const initial = document.createElement('span');
            initial.className = 'profile-initial';
            initial.textContent = instructorInitial;
            img.onerror = () => { img.style.display = 'none'; initial.style.display = 'block'; };
            profilePic.appendChild(img);
            profilePic.appendChild(initial);

            const messageBubble = document.createElement('div');
            messageBubble.className = 'message-bubble';
            if (isFallback) messageBubble.classList.add('fallback-transcription'); // Add class for fallback

            const textDiv = document.createElement('div');
            textDiv.className = 'transcription-text';

            // NEW: Highlighting logic
            let hasHighlight = false;
            if (highlightTerm) {
                try {
                    const escapedTerm = highlightTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // Escape regex special chars
                    const regex = new RegExp(`(${escapedTerm})`, 'gi'); // Global, case-insensitive
                    if (regex.test(text)) {
                        textDiv.innerHTML = text.replace(regex, '<mark class="search-highlight" style="background-color: var(--accent-color-light); color: var(--accent-color-dark); padding: 1px 3px; border-radius: 3px; font-weight: 600;">$1</mark>');
                        hasHighlight = true;
                        // Store the first highlighted element for scrolling
                        if (!firstHighlightElement) {
                            messageWrapper.id = `highlight-${transcriptionId}`; // Add an ID for targeting
                            firstHighlightElement = messageWrapper;
                            console.log(`First highlight found in transcription ID: ${transcriptionId}`);
                        }
                    } else {
                        textDiv.textContent = text; // No match, set text normally
                    }
                } catch (e) {
                    console.error("Highlighting regex error:", e);
                    textDiv.textContent = text; // Fallback on regex error
                }
            } else {
                textDiv.textContent = text; // No highlight term provided
            }

            messageBubble.appendChild(textDiv);
            messageWrapper.appendChild(profilePic);
            messageWrapper.appendChild(messageBubble);

            messageBubble.addEventListener('click', () => selectMessageBubble(messageBubble, text)); // Pass original text to modal
            transcriptionContent.appendChild(messageWrapper);
        }

        // Show status message
        function showStatus(message, type = 'success') {
            statusIndicator.textContent = message;
            statusIndicator.className = `status-indicator visible ${type === 'error' ? 'error' : ''}`;
            setTimeout(() => statusIndicator.classList.remove('visible'), 3000);
        }

        // Show error page content
        function showErrorPage(message) {
            document.body.innerHTML = `
                <div style="padding: 40px; text-align: center; color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; margin: 50px auto; max-width: 600px;">
                    <h1>Error</h1>
                    <p>${message}</p>
                    <a href="/" style="display: inline-block; margin-top: 20px; color: #007bff; text-decoration: underline;">Return to Home</a>
                </div>`;
        }

        // Select message bubble
        function selectMessageBubble(bubble, text) {
            if (lastClickedElement) lastClickedElement.classList.remove('clicked');
            bubble.classList.add('clicked');
            lastClickedElement = bubble;
            openModal(text);
        }

        // Modal functions
        function openModal(text) {
            selectedText = text;
            modal.style.display = 'block';
            document.getElementById('modalTitle').textContent = 'Select an option';
            resetModalState();
            setTimeout(() => modal.classList.add('visible'), 10);
        }

        function closeModal() {
            modal.classList.remove('visible');
            setTimeout(() => {
                modal.style.display = 'none';
                resetModalState();
                if (lastClickedElement) lastClickedElement.classList.remove('clicked');
                lastClickedElement = null;
            }, 300); // Match CSS transition duration
        }

        function resetModalState() {
            loadingSpinnerModal.style.display = 'none';
            explanationText.style.display = 'none';
            errorMessageModal.style.display = 'none';
            explanationText.innerHTML = ''; // Use innerHTML for markdown
            optionButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('.option-buttons').style.visibility = 'visible'; // Ensure options are visible
            selectedOption = null;
        }

        // Get explanation/summary
        async function getExplanation(option) { // Make async
            if (!option) return;
            selectedOption = option; // Store the selected option ('define', 'explain', 'examples', 'simplify', 'practice')
            optionButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.option === option));

            document.getElementById('modalTitle').textContent = getOptionTitle(option);
            loadingSpinnerModal.style.display = 'block';
            explanationText.style.display = 'none'; // Hide initially
            errorMessageModal.style.display = 'none';
            explanationText.innerHTML = ''; // Clear previous content

            let accumulatedExplanation = ''; // To store streamed content

            try {
                const response = await fetch('/get_explanation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    // Send 'practice' for the new option, otherwise use the standard endpoint
                    body: JSON.stringify({ text: selectedText, option: option }), // Backend needs to handle 'practice'
                    credentials: 'same-origin'
                });

                if (!response.ok) {
                    // Try to parse error from body, otherwise use status text
                    let errorMsg = `HTTP error! status: ${response.status}`;
                    try {
                        const errData = await response.json();
                        errorMsg = errData.error || errorMsg;
                    } catch (e) { /* Ignore if body isn't JSON */ }
                    throw new Error(errorMsg);
                }

                // Handle the stream
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                explanationText.style.display = 'block'; // Show text area now

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break; // Stream finished

                    const decodedChunk = decoder.decode(value, { stream: true });
                    // Process potential multiple SSE messages in one chunk
                    const lines = decodedChunk.split('\n\n');
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const jsonData = JSON.parse(line.substring(6)); // Remove 'data: ' prefix
                                if (jsonData.chunk) {
                                    accumulatedExplanation += jsonData.chunk;
                                    // Update UI incrementally
                                    explanationText.innerHTML = marked.parse(accumulatedExplanation);
                                    // Optional: Scroll to bottom if needed
                                    explanationText.scrollTop = explanationText.scrollHeight;
                                } else if (jsonData.done) {
                                    // Optional: Final processing if needed
                                    console.log("Stream finished signal received.");
                                    // The loop will break anyway due to 'done' from reader.read()
                                } else if (jsonData.error) {
                                    console.error("SSE Error:", jsonData.error);
                                    showModalError(jsonData.error);
                                    return; // Stop processing on error
                                }
                            } catch (e) {
                                console.error("Error parsing SSE data:", e, "Data:", line);
                            }
                        }
                    }
                }
                // Final render after stream completes (optional, usually covered by incremental updates)
                explanationText.innerHTML = marked.parse(accumulatedExplanation);

            } catch (error) {
                console.error('Explanation Fetch/Stream Error:', error);
                showModalError('Error getting explanation: ' + error.message);
            } finally {
                loadingSpinnerModal.style.display = 'none'; // Hide spinner regardless of success/failure
            }
        }

        async function getSummary(minutes) { // Make async
            const cutoffTime = new Date(Date.now() - minutes * 60 * 1000);
            const relevantTranscriptions = transcriptionHistory
                .filter(item => item.timestamp >= cutoffTime)
                .map(item => item.text)
                .join(' ');

            if (!relevantTranscriptions.trim()) {
                showStatus(`No transcriptions in the last ${minutes} minute${minutes === 1 ? '' : 's'}.`, 'error');
                return;
            }

            modal.style.display = 'block';
            setTimeout(() => modal.classList.add('visible'), 10);
            document.getElementById('modalTitle').textContent = `Summary of Last ${minutes} Minute${minutes === 1 ? '' : 's'}`;
            loadingSpinnerModal.style.display = 'block';
            explanationText.style.display = 'none'; // Hide initially
            errorMessageModal.style.display = 'none';
            explanationText.innerHTML = ''; // Clear previous content
            document.querySelector('.option-buttons').style.visibility = 'hidden'; // Keep options hidden for summary

            let accumulatedSummary = ''; // To store streamed content

            try {
                const response = await fetch('/get_summary', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: relevantTranscriptions, minutes: minutes }),
                    credentials: 'same-origin'
                });

                if (!response.ok) {
                    let errorMsg = `HTTP error! status: ${response.status}`;
                    try {
                        const errData = await response.json();
                        errorMsg = errData.error || errorMsg;
                    } catch (e) { /* Ignore if body isn't JSON */ }
                    throw new Error(errorMsg);
                }

                // Handle the stream
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                explanationText.style.display = 'block'; // Show text area now

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break; // Stream finished

                    const decodedChunk = decoder.decode(value, { stream: true });
                    const lines = decodedChunk.split('\n\n');
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const jsonData = JSON.parse(line.substring(6));
                                if (jsonData.chunk) {
                                    accumulatedSummary += jsonData.chunk;
                                    explanationText.innerHTML = marked.parse(accumulatedSummary);
                                    explanationText.scrollTop = explanationText.scrollHeight;
                                } else if (jsonData.done) {
                                    console.log("Stream finished signal received.");
                                } else if (jsonData.error) {
                                    console.error("SSE Error:", jsonData.error);
                                    showModalError(jsonData.error);
                                    return;
                                }
                            } catch (e) {
                                console.error("Error parsing SSE data:", e, "Data:", line);
                            }
                        }
                    }
                }
                // Final render after stream completes
                explanationText.innerHTML = marked.parse(accumulatedSummary);

            } catch (error) {
                console.error('Summary Fetch/Stream Error:', error);
                showModalError('Error getting summary: ' + error.message);
            } finally {
                loadingSpinnerModal.style.display = 'none'; // Hide spinner
            }
        }


        function getOptionTitle(option) { // Add title for the new practice option
            const titles = { define: 'Definition', explain: 'Detailed Explanation', examples: 'Real-World Examples', simplify: 'Simplified Explanation', practice: 'Practice Problems' };
            return titles[option] || 'Result'; // Generic fallback
        }

        function showModalError(message) {
            loadingSpinnerModal.style.display = 'none'; // Hide spinner on error
            errorMessageModal.style.display = 'block';
            errorMessageModal.querySelector('p').textContent = message + ' '; // Add space before retry
            errorMessageModal.querySelector('p').appendChild(retryButton);
        }

        // Helpers
        function formatDate(dateString) {
            if (!dateString) return 'N/A';
            try { return new Date(dateString).toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' }); }
            catch (e) { return dateString; }
        }
        function formatTime(timeString) {
            if (!timeString) return 'N/A';
            try {
                const [hours, minutes] = timeString.split(':');
                const date = new Date(); date.setHours(hours, minutes);
                return date.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit', hour12: true });
            } catch (e) { return timeString; }
        }

        // Event listeners
        document.querySelectorAll('.summary-button').forEach(button => {
            button.addEventListener('click', () => getSummary(parseInt(button.dataset.minutes)));
        });
        optionButtons.forEach(button => {
            button.addEventListener('click', () => getExplanation(button.dataset.option)); // This now handles the 'practice' option too
        });
        retryButton.addEventListener('click', () => {
            // Retry logic needs to know if it was a summary or explanation/practice
            if (selectedOption) { // If an option was selected in the modal
                 getExplanation(selectedOption);
            } else if (document.getElementById('modalTitle').textContent.startsWith('Summary')) {
                // Basic retry for summary - might need refinement if multiple summary types exist
                const minutesText = document.getElementById('modalTitle').textContent.match(/Last (\d+)/);
                if (minutesText && minutesText[1]) {
                    getSummary(parseInt(minutesText[1]));
                } else {
                    // Could add retry for entire summary here if needed
                    console.warn("Could not determine summary type for retry.");
                }
            } else {
                 // Could add retry for lecture practice problems or notes here if needed
                 console.warn("Could not determine action type for retry.");
            }
        });
        document.addEventListener('keydown', (event) => { if (event.key === 'Escape' && modal.style.display === 'block') closeModal(); });

        // --- New Event Listeners for Lecture-Wide Actions ---

        summaryEntireButton?.addEventListener('click', () => getEntireSummary());
        practiceProblemsLectureButton?.addEventListener('click', () => getLecturePracticeProblems());
        lectureNotesButton?.addEventListener('click', () => createLectureNotesPDF());


        // --- New Functions for Lecture-Wide Actions ---

        async function getEntireSummary() {
            const allTranscriptionsText = transcriptionHistory.map(item => item.text).join(' ');
            if (!allTranscriptionsText.trim()) {
                showStatus('No transcriptions available for the entire lecture yet.', 'error');
                return;
            }

            openModalForProcessing('Summary of Entire Lecture');

            let accumulatedSummary = '';
            try {
                // --- Start backend integration here ---
                const response = await fetch('/get_summary_entire', { // NEW ENDPOINT
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: allTranscriptionsText, lecture_code: lectureCode }), // Send all text
                    credentials: 'same-origin'
                });

                if (!response.ok) { throw await parseError(response); }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                explanationText.style.display = 'block'; // Show text area

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    const decodedChunk = decoder.decode(value, { stream: true });
                    const lines = decodedChunk.split('\n\n');
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const jsonData = JSON.parse(line.substring(6));
                                if (jsonData.chunk) {
                                    accumulatedSummary += jsonData.chunk;
                                    explanationText.innerHTML = marked.parse(accumulatedSummary);
                                    explanationText.scrollTop = explanationText.scrollHeight;
                                } else if (jsonData.error) { throw new Error(jsonData.error); }
                            } catch (e) { console.error("Error parsing SSE data:", e, "Data:", line); }
                        }
                    }
                }
                // Final render after stream completes (optional, usually covered by incremental updates)
                explanationText.innerHTML = marked.parse(accumulatedSummary);
                // --- End backend integration ---
            } catch (error) {
                console.error('Entire Summary Fetch Error:', error);
                showModalError('Error getting entire summary: ' + error.message);
            } finally {
                loadingSpinnerModal.style.display = 'none';
            }
        }

        async function getLecturePracticeProblems() {
            const allTranscriptionsText = transcriptionHistory.map(item => item.text).join(' ');
             if (!allTranscriptionsText.trim()) {
                showStatus('No transcriptions available to generate practice problems.', 'error');
                return;
            }

            openModalForProcessing('Practice Problems (Entire Lecture)');

            let accumulatedProblems = '';
            try {
                // --- Start backend integration here ---
                const response = await fetch('/generate_practice_problems_lecture', { // NEW ENDPOINT
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: allTranscriptionsText, lecture_code: lectureCode }),
                    credentials: 'same-origin'
                });

                if (!response.ok) { throw await parseError(response); }

                // Handle stream similar to getEntireSummary...
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                explanationText.style.display = 'block'; // Show text area

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    const decodedChunk = decoder.decode(value, { stream: true });
                    const lines = decodedChunk.split('\n\n');
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const jsonData = JSON.parse(line.substring(6));
                                if (jsonData.chunk) {
                                    accumulatedProblems += jsonData.chunk;
                                    explanationText.innerHTML = marked.parse(accumulatedProblems);
                                    explanationText.scrollTop = explanationText.scrollHeight;
                                } else if (jsonData.error) { throw new Error(jsonData.error); }
                            } catch (e) { console.error("Error parsing SSE data:", e, "Data:", line); }
                        }
                    }
                }
                // Final render after stream completes
                explanationText.innerHTML = marked.parse(accumulatedProblems);
                 // --- End backend integration ---
            } catch (error) {
                console.error('Lecture Practice Problems Fetch Error:', error);
                showModalError('Error generating practice problems: ' + error.message);
            } finally {
                loadingSpinnerModal.style.display = 'none';
            }
        }

        async function createLectureNotesPDF() {
            const allTranscriptionsText = transcriptionHistory.map(item => item.text).join(' ');
             if (!allTranscriptionsText.trim()) {
                showStatus('No transcriptions available to create lecture notes.', 'error');
                return;
            }

            showStatus('Generating lecture notes PDF...', 'info'); // Use status indicator for this

            try {
                // TODO: Replace with actual API call to '/create_lecture_notes'
                console.log("Sending request for lecture notes PDF...");

                // Include metadata along with transcriptions
                const requestBody = {
                    text: allTranscriptionsText,
                    lecture_code: lectureCode,
                    course_code: lectureData?.metadata?.course_code || 'N/A',
                    instructor: lectureData?.metadata?.instructor || 'N/A',
                    date: lectureData?.metadata?.date || 'N/A',
                    time: lectureData?.metadata?.time || 'N/A',
                    // Add student ID if available (e.g., from auth context on server)
                };

                const response = await fetch('/create_lecture_notes', { // NEW ENDPOINT
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    credentials: 'same-origin'
                });

                if (!response.ok) {
                    throw await parseError(response);
                }

                // Handle PDF download
                const blob = await response.blob();
                if (blob.type !== 'application/pdf') {
                     throw new Error('Server did not return a PDF file.');
                }

                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                // Create a filename (e.g., LectureNotes_CS101_2025-04-02.pdf)
                const safeCourseCode = (lectureData?.metadata?.course_code || 'Lecture').replace(/[^a-z0-9]/gi, '_');
                const safeDate = (lectureData?.metadata?.date ? formatDate(lectureData.metadata.date).replace(/[^a-z0-9]/gi, '-') : new Date().toISOString().split('T')[0]);
                a.download = `LectureNotes_${safeCourseCode}_${safeDate}.pdf`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                a.remove();
                showStatus('Lecture notes PDF downloaded successfully.', 'success');

            } catch (error) {
                console.error('Create Lecture Notes Error:', error);
                showStatus(`Error creating lecture notes: ${error.message}`, 'error');
            }
            // No modal involved here, just status updates.
        }

        // Helper to open modal for processing lecture-wide actions
        function openModalForProcessing(title) {
            modal.style.display = 'block';
            setTimeout(() => modal.classList.add('visible'), 10);
            document.getElementById('modalTitle').textContent = title;
            loadingSpinnerModal.style.display = 'block';
            explanationText.style.display = 'none';
            errorMessageModal.style.display = 'none';
            explanationText.innerHTML = '';
            document.querySelector('.option-buttons').style.visibility = 'hidden'; // Hide options
            selectedOption = null; // Clear selected option from bubble clicks
        }

        // Helper to parse error messages from fetch responses
        async function parseError(response) {
            let errorMsg = `Request failed with status: ${response.status}`;
            try {
                const errData = await response.json();
                errorMsg = errData.error || errorMsg;
            } catch (e) { /* Ignore if body isn't JSON */ }
            return new Error(errorMsg);
        }

    </script>
</body>
</html>